<!doctype html>
<html lang="tr">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>ðŸ“» Basâ€‘KonuÅŸ (Global | HTTPâ€‘only Supabase)</title>
  <style>
    :root { --bg:#0f172a; --card:#111827; --muted:#94a3b8; --text:#e5e7eb; --accent:#22c55e; --danger:#ef4444; --warning:#f59e0b; }
    html,body{height:100%;margin:0;background:var(--bg);color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif}
    .wrap{max-width:720px;margin:24px auto;padding:0 16px}
    header{display:flex;align-items:center;justify-content:space-between;margin-bottom:16px}
    h1{font-size:1.15rem;margin:0}
    .card{background:var(--card);border:1px solid #1f2937;border-radius:12px;padding:16px;margin-bottom:16px}
    .status{display:flex;align-items:center;gap:8px;font-weight:600}
    .dot{width:10px;height:10px;border-radius:50%}
    .dot.green{background:var(--accent)}
    .dot.red{background:var(--danger)}
    .dot.yellow{background:var(--warning)}
    .ptt{display:flex;flex-direction:column;align-items:center;gap:14px;padding:24px}
    .ptt .big{width:240px;height:240px;border-radius:50%;font-size:1.2rem;background:#22c55e;color:#001;border:none;cursor:pointer;font-weight:900;display:flex;align-items:center;justify-content:center;box-shadow:0 10px 40px rgba(34,197,94,.3);transition:transform .05s,filter .15s}
    .ptt .big.holding{background:#16a34a;box-shadow:0 10px 50px rgba(34,197,94,.5)}
    .hint{color:var(--muted);font-size:.92rem;text-align:center}
    .error{color:#fff;background:#b91c1c;border:1px solid #7f1d1d;padding:10px;border-radius:10px;margin-top:10px;display:none}
    footer{color:var(--muted);font-size:.85rem;margin-top:14px;text-align:center}
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>ðŸ“» Basâ€‘KonuÅŸ (Global Hat â€“ HTTP)</h1>
      <div class="status" id="floorStatus"><span class="dot yellow"></span><span>BaÄŸlanÄ±lÄ±yorâ€¦</span></div>
    </header>

    <div class="card ptt">
      <button id="pttButton" class="big" disabled>Basâ€‘KonuÅŸ</button>
      <div class="hint">BasÄ±lÄ± tutarak konuÅŸun â€¢ Klavye: <b>Space</b></div>
      <div class="hint" id="info"></div>
      <div class="error" id="uiError"></div>
    </div>

    <footer>WebRTC ses uÃ§tan uca ÅŸifrelenir (DTLSâ€‘SRTP). HTTPS gereklidir.</footer>
  </div>

  <!-- Supabase JS (UMD) â€“ DOÄžRU KULLANIM -->
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2.45.4/dist/umd/supabase.min.js"></script>

  <script>
    // ====== YardÄ±mcÄ±lar / UI ======
    const elPTT = document.getElementById("pttButton");
    const elInfo = document.getElementById("info");
    const elFloor = document.getElementById("floorStatus");
    const uiError = document.getElementById("uiError");
    const setStatus = (color, text)=>{ const dot=elFloor.querySelector(".dot"); const span=elFloor.querySelector("span"); dot.className="dot "+color; span.textContent=text; };
    const info = (msg)=> elInfo.textContent = msg || "";
    const showErr = (msg)=>{ console.error(msg); uiError.textContent = msg; uiError.style.display='block'; };

    // ====== Supabase ======
    const SUPABASE_URL = "https://luyhfyhwqyzwdjpcfyyn.supabase.co";
    const SUPABASE_ANON_KEY = "sb_publishable_FftwyHK-9ZkFEp37Ejrv6A_ctj6mLFy";
    const sb = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

    // ====== Global ======
    const ROOM = "global";
    const FLOOR_TTL_MS = 7000;
    const SIGNAL_POLL_MS = 400;
    const PRESENCE_BEAT_MS = 2000;
    const PRESENCE_POLL_MS = 1000;
    const PRESENCE_TTL_MS = 12000;

    // ICE (TURN eklemek istersen buraya)
    const ICE_SERVERS = [
      { urls: "stun:stun.l.google.com:19302" },
      // { urls: "turn:turn.senin-domenin.com:3478", username: "user", credential: "pass" }
    ];

    const meId = crypto.randomUUID();

    // ====== Presence (HTTP) ======
    let presenceTimer=null, presencePollTimer=null;
    let activePeers = new Set(); // diÄŸer user_id'ler

    async function presenceBeat(){
      try {
        await sb.from('ptt_presence').upsert(
          { room: ROOM, user_id: meId, last_seen: new Date().toISOString() },
          { onConflict: 'room,user_id' }
        );
      } catch(e){ console.error('presenceBeat', e); }
    }
    async function pollPresence(){
      try {
        const cutoff = new Date(Date.now() - PRESENCE_TTL_MS).toISOString();
        const { data, error } = await sb
          .from('ptt_presence')
          .select('user_id,last_seen')
          .eq('room', ROOM)
          .gt('last_seen', cutoff);
        if (error){ console.error('pollPresence', error); return; }

        const nextActive = new Set((data||[]).map(r=>r.user_id));
        nextActive.delete(meId);

        // yeni gÃ¶rÃ¼lenlere deterministik offer (glare Ã¶nleme iÃ§in kÃ¼Ã§Ã¼k ID baÅŸlatÄ±r)
        for (const pid of nextActive){
          if (!activePeers.has(pid) && meId < pid){
            try { await makeOffer(pid); } catch(e){ console.error('makeOffer', e); }
          }
        }
        // ayrÄ±lanlarÄ± temizle
        for (const old of [...activePeers]){
          if (!nextActive.has(old)){
            const st = peers.get(old);
            if (st){ try { st.pc.close(); } catch{}; peers.delete(old); }
          }
        }
        activePeers = nextActive;
      } catch(e){ console.error(e); }
    }

    // ====== Signals (HTTP) ======
    let signalCursorId = 0;
    async function sendSignalHTTP({ to, from, type, payload }){
      try { await sb.from('ptt_signals').insert({ room: ROOM, to, from, type, payload }); }
      catch(e){ console.error('sendSignalHTTP', e); }
    }
    async function pollSignals(){
      try {
        const { data, error } = await sb
          .from('ptt_signals')
          .select('*')
          .eq('room', ROOM)
          .eq('to', meId)
          .gt('id', signalCursorId)
          .order('id', { ascending: true })
          .limit(100);
        if (error){ console.error('pollSignals', error); return; }

        for (const row of data || []){
          signalCursorId = Math.max(signalCursorId, row.id);
          const { from, type, payload } = row;
          if (type === 'offer')        await handleOffer(from, payload?.sdp);
          else if (type === 'answer')  await handleAnswer(from, payload?.sdp);
          else if (type === 'candidate') await handleCandidate(from, payload?.candidate);
        }
        // istersen iÅŸlendi sil:
        // if (signalCursorId) await sb.from('ptt_signals').delete().lte('id', signalCursorId).eq('to', meId).eq('room', ROOM);
      } catch(e){ console.error(e); }
    }

    // ====== WebRTC ======
    const peers = new Map(); // peerId -> { pc, audioEl, sender, negotiating, iAmCaller }
    let localStream = null;
    let localTrack = null;   // tek audio track (mic)
    let holding = false;
    let heartbeatTimer = null;

    async function initMic(){
      if (localStream) return;
      try {
        localStream = await navigator.mediaDevices.getUserMedia({ audio:true, video:false });
        localTrack = localStream.getAudioTracks()[0] || null;
        if (localTrack) { localTrack.enabled = false; }
        // var olan peer'larÄ±n transceiver sender'Ä±na tak
        peers.forEach(st=>{
          if (st.sender){
            st.sender.replaceTrack(localTrack).catch(()=>{});
          }
        });
      } catch(e){
        console.error(e);
        showErr("Mikrofon izni gerekli veya HTTPS deÄŸil. TarayÄ±cÄ± izinlerini kontrol edin.");
      }
    }

    function ensurePeer(peerId){
      if (peers.has(peerId)) return peers.get(peerId);

      const pc = new RTCPeerConnection({ iceServers: ICE_SERVERS });
      const state = { pc, audioEl: null, sender: null, negotiating: false, iAmCaller: (meId < peerId) };

      // ðŸ” Ã–NEMLÄ°: Tek bir audio mâ€‘line iÃ§in baÅŸtan transceiver aÃ§ (sendrecv)
      const tr = pc.addTransceiver('audio', { direction: 'sendrecv' });
      state.sender = tr.sender;

      // EÄŸer mic hazÄ±rsa sender'a tak (renegotiation tetikler)
      if (localTrack){
        state.sender.replaceTrack(localTrack).catch(()=>{});
      } else {
        state.sender.replaceTrack(null).catch(()=>{});
      }

      // Renegotiation: sadece 'caller' offer Ã¼retir
      pc.onnegotiationneeded = async () => {
        if (!state.iAmCaller) return;
        if (state.negotiating) return;
        state.negotiating = true;
        try {
          const offer = await pc.createOffer();
          await pc.setLocalDescription(offer);
          await sendSignalHTTP({ to: peerId, from: meId, type:"offer", payload:{ sdp: offer.sdp } });
        } catch (e) {
          console.warn("onnegotiationneeded error", e);
        } finally {
          state.negotiating = false;
        }
      };

      pc.onicecandidate = (ev)=>{
        if (ev.candidate) sendSignalHTTP({ to: peerId, from: meId, type:"candidate", payload:{ candidate: ev.candidate.toJSON() } });
      };
      pc.oniceconnectionstatechange = ()=> console.log('ICE', peerId, pc.iceConnectionState);
      pc.onconnectionstatechange   = ()=> console.log('PC', peerId, pc.connectionState);

      pc.ontrack = (ev)=>{
        if (!state.audioEl){
          const a = document.createElement('audio');
          a.autoplay = true; a.playsInline = true;
          a.srcObject = ev.streams[0];
          state.audioEl = a;
          a.play().catch(()=>{ /* iOS/Safari - ilk kullanÄ±cÄ± etkileÅŸimi gerekir; PTT basÄ±ÅŸÄ± yeter */ });
          // gÃ¶rÃ¼nmez bir yere ekle
          const hidden = document.createElement('div'); hidden.style.display='none'; hidden.appendChild(a);
          document.body.appendChild(hidden);
        }
      };

      peers.set(peerId, state);
      return state;
    }

    async function makeOffer(peerId){
      const { pc } = ensurePeer(peerId);
      // hÄ±zlÄ± baÅŸlatma (bazÄ± tarayÄ±cÄ±larda negotiationneeded'i beklemeden)
      const offer = await pc.createOffer();
      await pc.setLocalDescription(offer);
      await sendSignalHTTP({ to: peerId, from: meId, type:"offer", payload:{ sdp: offer.sdp } });
    }
    async function handleOffer(fromId, sdp){
      const { pc } = ensurePeer(fromId);
      await pc.setRemoteDescription({ type:"offer", sdp });
      await initMic(); // mic hazÄ±rla ve sender'a tak
      const ans = await pc.createAnswer();
      await pc.setLocalDescription(ans);
      await sendSignalHTTP({ to: fromId, from: meId, type:"answer", payload:{ sdp: ans.sdp } });
    }
    async function handleAnswer(fromId, sdp){
      const st = peers.get(fromId); if (!st) return;
      await st.pc.setRemoteDescription({ type:"answer", sdp });
    }
    async function handleCandidate(fromId, candidate){
      const st = ensurePeer(fromId);
      try { await st.pc.addIceCandidate(candidate); } catch(e){ console.warn(e); }
    }

    // ====== Floor (tek konuÅŸmacÄ±) ======
    async function acquireFloor(){
      try {
        const { data, error } = await sb.rpc('acquire_floor', { p_room: ROOM, p_me_id: meId, p_ttl_ms: FLOOR_TTL_MS });
        if (error){ console.error('acquire_floor', error); return false; }
        return !!data;
      } catch(e){ console.error(e); return false; }
    }
    async function releaseFloor(){
      try { await sb.rpc('release_floor', { p_room: ROOM, p_me_id: meId }); } catch(e){ console.error(e); }
    }
    async function touchFloor(){
      try { await sb.rpc('touch_floor', { p_room: ROOM, p_me_id: meId }); } catch(e){}
    }

    async function refreshFloorUI(){
      try {
        // SÃ¼resi geÃ§miÅŸse DB tarafÄ±nda bÄ±rak
        await sb.rpc('release_if_expired', { p_room: ROOM, p_ttl_ms: FLOOR_TTL_MS });

        const { data } = await sb.from('ptt_floor').select('*').eq('room', ROOM).maybeSingle();
        const val = data;
        if (!val || !val.holder_id){
          setStatus("green", "MÃ¼sait: KonuÅŸmaya hazÄ±r");
          if (!holding){ elPTT.disabled = false; }
        } else if (val.holder_id === meId){
          setStatus("yellow", "KonuÅŸuyorsunuz");
          elPTT.disabled = false;
        } else {
          setStatus("red", "MeÅŸgul: BaÅŸkasÄ± konuÅŸuyor");
          if (!holding) elPTT.disabled = true;

          // local TTL kontrolÃ¼ (gecikme varsa bir tur daha temizlemeyi dene)
          if (val.heartbeat){
            const expiredLocal = (Date.now() - new Date(val.heartbeat).getTime()) > (FLOOR_TTL_MS + 1500);
            if (expiredLocal){
              setTimeout(()=> sb.rpc('release_if_expired', { p_room: ROOM, p_ttl_ms: FLOOR_TTL_MS }).then(refreshFloorUI), 500);
            }
          }
        }
      } catch(e){ console.error(e); }
    }
    function startHeartbeat(){
      stopHeartbeat();
      heartbeatTimer = setInterval(()=>{ touchFloor(); refreshFloorUI(); }, 2000);
    }
    function stopHeartbeat(){ if (heartbeatTimer) clearInterval(heartbeatTimer); heartbeatTimer=null; }

    // ====== PTT UI ======
    async function pressDown(){
      if (holding) return;
      await initMic();

      // KonuÅŸma hakkÄ±nÄ± al
      const ok = await acquireFloor();
      if (!ok){ info("BaÅŸkasÄ± konuÅŸuyor. LÃ¼tfen bekleyinâ€¦"); refreshFloorUI(); return; }

      // TÃ¼m peer'larÄ±n sender'Ä±na mic'i tak (varsa) ve renegotiation'a gÃ¼ven
      peers.forEach(st=>{
        if (st.sender){
          st.sender.replaceTrack(localTrack).catch(()=>{});
        }
      });

      holding = true;
      elPTT.classList.add("holding");
      if (localTrack) localTrack.enabled = true;  // track aÃ§Ä±k
      startHeartbeat();
      info("KonuÅŸuyorsunuzâ€¦ BÄ±rakmak iÃ§in elinizi Ã§ekin.");
      refreshFloorUI();
    }
    async function pressUp(){
      if (!holding) return;
      holding = false;
      elPTT.classList.remove("holding");

      // track'i Ã§Ä±kar (karÅŸÄ± tarafa sessizlik yerine gerÃ§ekten gÃ¶nderimi durdur)
      peers.forEach(st=>{
        if (st.sender){
          st.sender.replaceTrack(null).catch(()=>{});
        }
      });
      if (localTrack) localTrack.enabled = false;

      stopHeartbeat();
      await releaseFloor();
      info("");
      refreshFloorUI();
    }

    elPTT.addEventListener("mousedown", pressDown);
    document.addEventListener("mouseup", pressUp);
    elPTT.addEventListener("touchstart", (e)=>{ e.preventDefault(); pressDown(); }, {passive:false});
    document.addEventListener("touchend", (e)=>{ e.preventDefault(); pressUp(); }, {passive:false});
    let keyHolding = false;
    document.addEventListener("keydown",(e)=>{ if(e.code==="Space"&&!keyHolding){ e.preventDefault(); keyHolding=true; pressDown(); }});
    document.addEventListener("keyup",(e)=>{ if(e.code==="Space"&&keyHolding){ e.preventDefault(); keyHolding=false; pressUp(); }});

    window.addEventListener("beforeunload", async ()=>{
      try { stopHeartbeat(); } catch {}
      try { await releaseFloor(); } catch {}
      try { await sb.from('ptt_presence').delete().eq('room', ROOM).eq('user_id', meId); } catch {}
    });

    // ====== BaÅŸlat ======
    (async function boot(){
      setStatus("yellow","BaÄŸlanÄ±lÄ±yorâ€¦ (HTTP)");
      info("Mikrofon izni ilk basÄ±ÅŸta istenebilir. WebSocket engellense bile bu sÃ¼rÃ¼m Ã§alÄ±ÅŸÄ±r.");

      // Presence
      await presenceBeat();
      presenceTimer = setInterval(presenceBeat, PRESENCE_BEAT_MS);
      presencePollTimer = setInterval(pollPresence, PRESENCE_POLL_MS);

      // Signaling
      setInterval(pollSignals, SIGNAL_POLL_MS);

      elPTT.disabled = false;
      refreshFloorUI();
    })();
  </script>
</body>
</html>
